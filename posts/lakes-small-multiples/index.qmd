---
title: "Lakes small multiples"
author: "Isaac Bain"
date: "2024-06-03"
categories: [code, water quality, maps]
execute:
  warning: false
  error: false
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
    toc: true
    toc-location: left
    number-sections: true
editor: visual
draft: true
---

I've been inspired by a new type of small multiples map I've seen, where multipolygons are extracted from their spatial locations and reassembled in a grid while maintaining their relative sizes. If you unsure what I mean, check out [this one](https://www.ordnancesurvey.co.uk/blog/britains-largest-islands) as an example. So I thought I'd try applying it to some lakes data in New Zealand.

## Libraries and import data

The Department of Conservation's Freshwater Ecosystems of New Zealand ([FENZ](https://www.doc.govt.nz/our-work/freshwater-ecosystems-of-new-zealand/)) geodatabase provided the lake boundary polygons. While one could also source these from the LINZ topo map layers, the advantage of the FENZ layer is that it can be linked to other datasets, such as modelled water quality.

The Ministry for the Environment provides modelled [lake water quality](https://data.mfe.govt.nz/table/109652-lake-water-quality-modelled-2016-2020/) data for 3,813 lakes in New Zealand that are larger than 1 hectare. This data can be joined using the FENZ lake ID. The dataset is generated by a statistical learning model (specifically, a random forest model) trained on actual monitoring data and using a number of environmental predictors to extrapolate out to unmeasured lakes.

```{r}
library(tidyverse)
library(sf)
library(gridExtra)

lakes <- st_read("data/fenz_v1_lakes/FENZ_v1_Lakes.shp", quiet = TRUE) |>
  janitor::clean_names() |> 
  drop_na(name)

wq <- read_csv("data/mfe-lake-water-quality-modelled-2016-2020-CSV/lake-water-quality-modelled-2016-2020.csv") |>
  janitor::clean_names() |> 
  filter(indicator == "TLI3")

lakes <- lakes |> 
  left_join(wq, by = c("lid" = "lfenzid"))
```

## What are the largest lakes in New Zealand?

Sorting the lakes dataset by size (surface area) and selecting the largest ones is a fairly straightforward task. Interestingly, there is a discrepancy between my data and this [Wikipedia page](https://en.wikipedia.org/wiki/List_of_lakes_of_New_Zealand) listing the sizes of lakes in NZ. Wikipedia lists it as 141 km^2^, whereas my data shows it as 152 km^2^. Since the Wikipedia article does not list its sources, the origin of this discrepancy remains unclear![^1]

[^1]: [Lakes380](https://lakes380.com/lakes/lake-hawea/) lists it as 151.77 km^2^, [Fish and Game](https://www.fishandgame.org.nz/freshwater-fishing-in-new-zealand/where-to-fish/regional-info/otago/lake-hawea/) as 124 km^2^, and [Queenstown Lakes District Council](https://www.qldc.govt.nz/media/dmlb401m/qldc_boating-guide_lakes-w%C4%81naka-and-h%C4%81wea.pdf) as 149 km^2^.

I've have also selected Trophic Level Index (TLI) as an indicator of water quality - more on that below.

```{r}
lakes_20 <- lakes |> 
  top_n(n = 20, wt = shape_area)

mapview::mapview(lakes_20)

lakes_20 |> 
  st_drop_geometry() |> 
  select(name, shape_area, value) |> 
  arrange(desc(shape_area)) |> 
  mutate(shape_area = shape_area / 1e6) |> 
  rename(Name = name,
         `Lake area (km2)` = shape_area,
         TLI3 = value) |> 
  knitr::kable(digits = 1)
```

There's an interesting pattern regarding lake size and water quality. None of the lakes with very low values of TLI3 (e.g \<2) are small. This could just be an artifact of the modelled data, perhaps a relationship that the model has learned incorrectly due to a strong bias in the training data. It would be better to using monitoring data here to confirm this relationship.

```{r}
lakes |> 
  st_drop_geometry() |> 
  select(name, shape_area, value) |> 
  mutate(shape_area = shape_area / 1e6) |> 
  ggplot(aes(value, shape_area)) +
  geom_point() +
  geom_smooth() +
  labs(x = "TLI3 score", y = "Lake area (km2)") +
  theme_minimal()
```

## Plot the 20 largest lakes

Now, let's get down to plotting the largest lakes, and colour them by their respective TLI3 score. LAWA provides a good [fact sheet](https://www.lawa.org.nz/learn/factsheets/lake-trophic-level-index) on what this metric means. In short:

> The Trophic Level Index (TLI) is a method of characterising the ecological health of lakes based on the amount of nutrients and algae growing in them. It provides an integrated measure of water quality that can be tracked over time and that can be used to estimate biological productivity. It is presented as a score, the lower the score the better the condition of the lake.

Here's what the scores correspond to in ecological terms:

| **TLI Score** | **Description**                                                                                                                                                                                                                         |
|:----------:|------------------------------------------------------------|
|      0–2      | Microtrophic: The lake is very clean with very low levels of nutrients and algae. The lake can have snow or glacial sources.                                                                                                            |
|     \>2–3     | Oligotrophic: The lake is clear and blue, with low levels of nutrients and algae.                                                                                                                                                       |
|     \>3–4     | Mesotrophic: The lake has moderate levels of nutrients and algae.                                                                                                                                                                       |
|     \>4–5     | Eutrophic: The lake is murky, with high amounts of nutrients and algae.                                                                                                                                                                 |
|      \>5      | Supertrophic: The lake has very high amounts of phosphorus and nitrogen, and can be overly fertile and often associated with poor water clarity. Excessive algae growth can occur. Suitability for recreational purposes is often poor. |

```{r fig.height=10,fig.width=7}

# Calculate centroids
lake_polygons <- lakes_20 %>%
  mutate(centroid = st_centroid(st_geometry(.)))

# Sort the lake polygons by shape_area in descending order
lake_polygons <- lake_polygons %>%
  arrange(desc(shape_area))

# Compute bounding boxes and find the maximum width and height
bboxes <- lapply(st_geometry(lake_polygons), function(x) as.numeric(st_bbox(x)))
max_width <- max(sapply(bboxes, function(x) abs(x[1] - x[3])))
max_height <- max(sapply(bboxes, function(x) abs(x[2] - x[4])))

# Set padding to ensure polygons are not cut off
padding <- 3500  # Adjust this value based on your specific spatial scale

# Calculate colors based on value
lake_polygons$color <- viridis::viridis(
  n = nrow(lake_polygons), 
  option = "D", 
  direction = 1
)[cut(lake_polygons$value, breaks = nrow(lake_polygons), labels = FALSE)]

# Function to make plots
graph <- function(x) {
  centroid <- st_coordinates(lake_polygons$centroid[x])
  ggplot(lake_polygons[x, ]) +
    geom_sf(fill = lake_polygons$color[x], colour = NA) +
    coord_sf(xlim = c(centroid[1] - max_width/2 - padding, centroid[1] + max_width/2 + padding), 
             ylim = c(centroid[2] - max_height/2 - padding, centroid[2] + max_height/2 + padding), 
             expand = FALSE) +
    theme_void() +
    ggtitle(str_wrap(lake_polygons$name[x], width = 20)) +
    theme(plot.title = element_text(hjust = 0.5, size = 10, vjust = 1),
          legend.position = "none")
}

# Create a list of plots
plot_list <- lapply(1:nrow(lake_polygons), FUN = graph)

# Combine plots and titles
combined_list <- lapply(plot_list, function(p) {
  title <- ggplot_build(p)$layout$panel_params[[1]]$title
  gridExtra::arrangeGrob(p, top = grid::textGrob(
    label = title,
    gp = grid::gpar(fontsize = 10),
    hjust = 0.5,
    vjust = 1
  ))
})

# Create the overall title and subtitle grobs
overall_title <- grid::textGrob("The 20 Largest Lakes of New Zealand", gp = grid::gpar(fontsize = 16, fontface = "bold"))
subtitle <- grid::textGrob("Coloured by Trophic Level Index", gp = grid::gpar(fontsize = 12))

# Create a common legend plot to extract the legend
legend_plot <- ggplot(lake_polygons) +
  geom_sf(aes(fill = value), colour = NA) +
  scale_fill_viridis_c(name = "TLI3", option = "D", direction = 1) +
  theme_void() +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 10, hjust = 0.5),
    legend.title.position = "top",
    legend.text = element_text(size = 8),
    legend.box.margin = margin(0, 0, 0, 0)
  )

# Extract the legend
legend_grob <- cowplot::get_plot_component(legend_plot, 'guide-box-bottom', return_all = TRUE)

# Arrange the plots together with the overall title and subtitle
final_plot <- gridExtra::grid.arrange(
  gridExtra::arrangeGrob(overall_title, subtitle, ncol = 1, heights = c(0.08, 0.05)),
  do.call(gridExtra::arrangeGrob, c(combined_list, ncol = 5)),
  legend_grob,
  nrow = 3,
  heights = c(0.1, 0.8, 0.1)
)
```

## Plot the 50 largest lakes

Bonus just for the blog readers... here's the plot for the 50 largest lakes in New Zealand! 

```{r fig.height=20,fig.width=7}
#| echo: false

lakes_50 <- lakes |> 
  top_n(n = 50, wt = shape_area)

# Calculate centroids
lake_polygons <- lakes_50 %>%
  mutate(centroid = st_centroid(st_geometry(.)))

# Sort the lake polygons by shape_area in descending order
lake_polygons <- lake_polygons %>%
  arrange(desc(shape_area))

# Compute bounding boxes and find the maximum width and height
bboxes <- lapply(st_geometry(lake_polygons), function(x) as.numeric(st_bbox(x)))
max_width <- max(sapply(bboxes, function(x) abs(x[1] - x[3])))
max_height <- max(sapply(bboxes, function(x) abs(x[2] - x[4])))

# Set padding to ensure polygons are not cut off
padding <- 3500  # Adjust this value based on your specific spatial scale

# Calculate colors based on value
lake_polygons$color <- viridis::viridis(
  n = nrow(lake_polygons), 
  option = "D", 
  direction = 1
)[cut(lake_polygons$value, breaks = nrow(lake_polygons), labels = FALSE)]

# Function to make plots
graph <- function(x) {
  centroid <- st_coordinates(lake_polygons$centroid[x])
  ggplot(lake_polygons[x, ]) +
    geom_sf(fill = lake_polygons$color[x], colour = NA) +
    coord_sf(xlim = c(centroid[1] - max_width/2 - padding, centroid[1] + max_width/2 + padding), 
             ylim = c(centroid[2] - max_height/2 - padding, centroid[2] + max_height/2 + padding), 
             expand = FALSE) +
    theme_void() +
    ggtitle(str_wrap(lake_polygons$name[x], width = 20)) +
    theme(plot.title = element_text(hjust = 0.5, size = 10, vjust = 1),
          legend.position = "none")
}

# Create a list of plots
plot_list <- lapply(1:nrow(lake_polygons), FUN = graph)

# Combine plots and titles
combined_list <- lapply(plot_list, function(p) {
  title <- ggplot_build(p)$layout$panel_params[[1]]$title
  gridExtra::arrangeGrob(p, top = grid::textGrob(
    label = title,
    gp = grid::gpar(fontsize = 10),
    hjust = 0.5,
    vjust = 1
  ))
})

# Create the overall title and subtitle grobs
overall_title <- grid::textGrob("The 50 Largest Lakes of New Zealand", gp = grid::gpar(fontsize = 16, fontface = "bold"))
subtitle <- grid::textGrob("Coloured by Trophic Level Index", gp = grid::gpar(fontsize = 12))

# Create a common legend plot to extract the legend
legend_plot <- ggplot(lake_polygons) +
  geom_sf(aes(fill = value), colour = NA) +
  scale_fill_viridis_c(name = "TLI3", option = "D", direction = 1) +
  theme_void() +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 10, hjust = 0.5),
    legend.title.position = "top",
    legend.text = element_text(size = 8),
    legend.box.margin = margin(0, 0, 0, 0)
  )

# Extract the legend
legend_grob <- cowplot::get_plot_component(legend_plot, 'guide-box-bottom', return_all = TRUE)

# Arrange the plots together with the overall title and subtitle
final_plot <- gridExtra::grid.arrange(
  gridExtra::arrangeGrob(overall_title, subtitle, ncol = 1, heights = c(0.08, 0.05)),
  do.call(gridExtra::arrangeGrob, c(combined_list, ncol = 5)),
  legend_grob,
  nrow = 3,
  heights = c(0.1, 0.8, 0.1)
)
```

## Next steps

-   Plot the smallest 20 lakes

-   Make an estuaries small multiples map

-   Figure out how to shrink the rows for the smaller lakes
